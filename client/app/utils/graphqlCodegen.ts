import gql from 'graphql-tag';
import * as VueApolloComposable from '@vue/apollo-composable';
import type * as VueCompositionApi from 'vue';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type ReactiveFunction<TParam> = () => TParam;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  ISO8601DateTime: { input: string; output: string; }
};

/** Autogenerated input type of AcceptConnectionRequest */
export type AcceptConnectionRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  connectionId: Scalars['ID']['input'];
};

/** Autogenerated return type of AcceptConnectionRequest. */
export type AcceptConnectionRequestPayload = {
  __typename?: 'AcceptConnectionRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

export type Company = {
  __typename?: 'Company';
  description: Maybe<Scalars['String']['output']>;
  /** The geographic location of the company */
  headquarters: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  /** A slug ID to be used in an SEO-friendly URI */
  slug: Scalars['String']['output'];
  /** Return a paginated list of users */
  users: UserConnection;
};


export type CompanyUsersArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Company. */
export type CompanyConnection = {
  __typename?: 'CompanyConnection';
  /** A list of edges. */
  edges: Maybe<Array<Maybe<CompanyEdge>>>;
  /** A list of nodes. */
  nodes: Maybe<Array<Maybe<Company>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CompanyEdge = {
  __typename?: 'CompanyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Maybe<Company>;
};

export type Connection = {
  __typename?: 'Connection';
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  /** The user who received the connection request */
  recipient: User;
  recipientId: Scalars['Int']['output'];
  /** The user who sent the connection request */
  requester: User;
  requesterId: Scalars['Int']['output'];
  status: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Autogenerated input type of CreatePost */
export type CreatePostInput = {
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreatePost. */
export type CreatePostPayload = {
  __typename?: 'CreatePostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  postId: Maybe<Scalars['ID']['output']>;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DeclineConnectionRequest */
export type DeclineConnectionRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  connectionId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeclineConnectionRequest. */
export type DeclineConnectionRequestPayload = {
  __typename?: 'DeclineConnectionRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DestroyPost */
export type DestroyPostInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  postId: Scalars['ID']['input'];
};

/** Autogenerated return type of DestroyPost. */
export type DestroyPostPayload = {
  __typename?: 'DestroyPostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

export type Mutation = {
  __typename?: 'Mutation';
  acceptConnectionRequest: Maybe<AcceptConnectionRequestPayload>;
  createPost: Maybe<CreatePostPayload>;
  declineConnectionRequest: Maybe<DeclineConnectionRequestPayload>;
  destroyPost: Maybe<DestroyPostPayload>;
  removeConnection: Maybe<RemoveConnectionPayload>;
  sendConnectionRequest: Maybe<SendConnectionRequestPayload>;
  updatePost: Maybe<UpdatePostPayload>;
};


export type MutationAcceptConnectionRequestArgs = {
  input: AcceptConnectionRequestInput;
};


export type MutationCreatePostArgs = {
  input: CreatePostInput;
};


export type MutationDeclineConnectionRequestArgs = {
  input: DeclineConnectionRequestInput;
};


export type MutationDestroyPostArgs = {
  input: DestroyPostInput;
};


export type MutationRemoveConnectionArgs = {
  input: RemoveConnectionInput;
};


export type MutationSendConnectionRequestArgs = {
  input: SendConnectionRequestInput;
};


export type MutationUpdatePostArgs = {
  input: UpdatePostInput;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['String']['output']>;
};

/** A network post */
export type Post = {
  __typename?: 'Post';
  body: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  /** User comments on this post */
  postComments: Maybe<PostCommentConnection>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  /** The post author */
  user: User;
};


/** A network post */
export type PostPostCommentsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};

export type PostComment = {
  __typename?: 'PostComment';
  body: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  user: User;
};

/** The connection type for PostComment. */
export type PostCommentConnection = {
  __typename?: 'PostCommentConnection';
  /** A list of edges. */
  edges: Maybe<Array<Maybe<PostCommentEdge>>>;
  /** A list of nodes. */
  nodes: Maybe<Array<Maybe<PostComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PostCommentEdge = {
  __typename?: 'PostCommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Maybe<PostComment>;
};

/** The connection type for Post. */
export type PostConnection = {
  __typename?: 'PostConnection';
  /** A list of edges. */
  edges: Maybe<Array<Maybe<PostEdge>>>;
  /** A list of nodes. */
  nodes: Maybe<Array<Maybe<Post>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PostEdge = {
  __typename?: 'PostEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Maybe<Post>;
};

export type Query = {
  __typename?: 'Query';
  /** A paginated list of companies */
  companies: CompanyConnection;
  /** Find a company by slug */
  company: Maybe<Company>;
  post: Post;
  /** A paginated list of posts */
  posts: PostConnection;
  /** Find a user by slug */
  user: Maybe<User>;
  /** A paginated list of users */
  users: UserConnection;
};


export type QueryCompaniesArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};


export type QueryCompanyArgs = {
  slug: Scalars['String']['input'];
};


export type QueryPostArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPostsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};


export type QueryUserArgs = {
  slug: Scalars['String']['input'];
};


export type QueryUsersArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of RemoveConnection */
export type RemoveConnectionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  connectionId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveConnection. */
export type RemoveConnectionPayload = {
  __typename?: 'RemoveConnectionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of SendConnectionRequest */
export type SendConnectionRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  recipientId: Scalars['ID']['input'];
  requesterId: Scalars['ID']['input'];
};

/** Autogenerated return type of SendConnectionRequest. */
export type SendConnectionRequestPayload = {
  __typename?: 'SendConnectionRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of UpdatePost */
export type UpdatePostInput = {
  body: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: InputMaybe<Scalars['String']['input']>;
  postId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdatePost. */
export type UpdatePostPayload = {
  __typename?: 'UpdatePostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

/** A user of the social network */
export type User = {
  __typename?: 'User';
  about: Maybe<Scalars['String']['output']>;
  company: Company;
  connectionTotal: Scalars['Int']['output'];
  /** A paginated list of connections for this user */
  connections: Maybe<UserConnection>;
  /** The post-nominal letters (e.g., M.D.) for the user */
  credentials: Maybe<Scalars['String']['output']>;
  firstName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  lastName: Scalars['String']['output'];
  middleName: Maybe<Scalars['String']['output']>;
  /** The user's full name and credentials, if any exist */
  nameWithCredentials: Scalars['String']['output'];
  nickname: Maybe<Scalars['String']['output']>;
  /** Pending connection requests received by this user */
  pendingReceivedRequests: Maybe<Array<Connection>>;
  /** Pending connection requests sent by this user */
  pendingSentRequests: Maybe<Array<Connection>>;
  /** A paginated list of posts for this user */
  posts: PostConnection;
  /** A slug ID to be used in an SEO-friendly URI */
  slug: Scalars['String']['output'];
};


/** A user of the social network */
export type UserConnectionsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};


/** A user of the social network */
export type UserPostsArgs = {
  after: InputMaybe<Scalars['String']['input']>;
  before: InputMaybe<Scalars['String']['input']>;
  first: InputMaybe<Scalars['Int']['input']>;
  last: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for User. */
export type UserConnection = {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Maybe<User>;
};

export type CreatePostMutationVariables = Exact<{
  userId: Scalars['ID']['input'];
  body: Scalars['String']['input'];
}>;


export type CreatePostMutation = { __typename?: 'Mutation', createPost: { __typename?: 'CreatePostPayload', success: boolean, postId: string | null, errors: Array<string> } | null };

export type DestroyPostMutationVariables = Exact<{
  postId: Scalars['ID']['input'];
}>;


export type DestroyPostMutation = { __typename?: 'Mutation', destroyPost: { __typename?: 'DestroyPostPayload', success: boolean, errors: Array<string> } | null };

export type GetCompanyQueryVariables = Exact<{
  slug: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCompanyQuery = { __typename?: 'Query', company: { __typename?: 'Company', slug: string, name: string, headquarters: string, description: string | null, users: { __typename?: 'UserConnection', edges: Array<{ __typename?: 'UserEdge', cursor: string, node: { __typename?: 'User', slug: string, nameWithCredentials: string } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor: string | null, endCursor: string | null } } } | null };

export type GetPostQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetPostQuery = { __typename?: 'Query', post: { __typename?: 'Post', body: string, createdAt: string, updatedAt: string, user: { __typename?: 'User', slug: string, nameWithCredentials: string }, postComments: { __typename?: 'PostCommentConnection', edges: Array<{ __typename?: 'PostCommentEdge', cursor: string, node: { __typename?: 'PostComment', id: string, body: string, user: { __typename?: 'User', slug: string, nameWithCredentials: string } } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor: string | null, endCursor: string | null } } | null } };

export type GetPostsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetPostsQuery = { __typename?: 'Query', posts: { __typename?: 'PostConnection', edges: Array<{ __typename?: 'PostEdge', cursor: string, node: { __typename?: 'Post', id: string, body: string, createdAt: string, updatedAt: string, user: { __typename?: 'User', nameWithCredentials: string, slug: string } } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', startCursor: string | null, endCursor: string | null, hasNextPage: boolean, hasPreviousPage: boolean } } };

export type GetUserQueryVariables = Exact<{
  slug: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetUserQuery = { __typename?: 'Query', user: { __typename?: 'User', slug: string, nameWithCredentials: string, about: string | null, connectionTotal: number, company: { __typename?: 'Company', slug: string, name: string }, posts: { __typename?: 'PostConnection', edges: Array<{ __typename?: 'PostEdge', cursor: string, node: { __typename?: 'Post', id: string, body: string } | null } | null> | null } } | null };

export type GetUserConnectionsQueryVariables = Exact<{
  slug: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetUserConnectionsQuery = { __typename?: 'Query', user: { __typename?: 'User', connectionTotal: number, connections: { __typename?: 'UserConnection', edges: Array<{ __typename?: 'UserEdge', cursor: string, node: { __typename?: 'User', slug: string, nameWithCredentials: string } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', startCursor: string | null, endCursor: string | null, hasPreviousPage: boolean, hasNextPage: boolean } } | null } | null };

export type GetUsersQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetUsersQuery = { __typename?: 'Query', users: { __typename?: 'UserConnection', edges: Array<{ __typename?: 'UserEdge', cursor: string, node: { __typename?: 'User', slug: string, nameWithCredentials: string } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', startCursor: string | null, endCursor: string | null, hasNextPage: boolean, hasPreviousPage: boolean } } };

export type UpdatePostMutationVariables = Exact<{
  postId: Scalars['ID']['input'];
  body: Scalars['String']['input'];
}>;


export type UpdatePostMutation = { __typename?: 'Mutation', updatePost: { __typename?: 'UpdatePostPayload', success: boolean, errors: Array<string> } | null };


export const CreatePostDocument = gql`
    mutation CreatePost($userId: ID!, $body: String!) {
  createPost(input: {userId: $userId, body: $body}) {
    success
    postId
    errors
  }
}
    `;

/**
 * __useCreatePostMutation__
 *
 * To run a mutation, you first call `useCreatePostMutation` within a Vue component and pass it any options that fit your needs.
 * When your component renders, `useCreatePostMutation` returns an object that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - Several other properties: https://v4.apollo.vuejs.org/api/use-mutation.html#return
 *
 * @param options that will be passed into the mutation, supported options are listed on: https://v4.apollo.vuejs.org/guide-composable/mutation.html#options;
 *
 * @example
 * const { mutate, loading, error, onDone } = useCreatePostMutation({
 *   variables: {
 *     userId: // value for 'userId'
 *     body: // value for 'body'
 *   },
 * });
 */
export function useCreatePostMutation(options: VueApolloComposable.UseMutationOptions<CreatePostMutation, CreatePostMutationVariables> | ReactiveFunction<VueApolloComposable.UseMutationOptions<CreatePostMutation, CreatePostMutationVariables>> = {}) {
  return VueApolloComposable.useMutation<CreatePostMutation, CreatePostMutationVariables>(CreatePostDocument, options);
}
export type CreatePostMutationCompositionFunctionResult = VueApolloComposable.UseMutationReturn<CreatePostMutation, CreatePostMutationVariables>;
export const DestroyPostDocument = gql`
    mutation DestroyPost($postId: ID!) {
  destroyPost(input: {postId: $postId}) {
    success
    errors
  }
}
    `;

/**
 * __useDestroyPostMutation__
 *
 * To run a mutation, you first call `useDestroyPostMutation` within a Vue component and pass it any options that fit your needs.
 * When your component renders, `useDestroyPostMutation` returns an object that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - Several other properties: https://v4.apollo.vuejs.org/api/use-mutation.html#return
 *
 * @param options that will be passed into the mutation, supported options are listed on: https://v4.apollo.vuejs.org/guide-composable/mutation.html#options;
 *
 * @example
 * const { mutate, loading, error, onDone } = useDestroyPostMutation({
 *   variables: {
 *     postId: // value for 'postId'
 *   },
 * });
 */
export function useDestroyPostMutation(options: VueApolloComposable.UseMutationOptions<DestroyPostMutation, DestroyPostMutationVariables> | ReactiveFunction<VueApolloComposable.UseMutationOptions<DestroyPostMutation, DestroyPostMutationVariables>> = {}) {
  return VueApolloComposable.useMutation<DestroyPostMutation, DestroyPostMutationVariables>(DestroyPostDocument, options);
}
export type DestroyPostMutationCompositionFunctionResult = VueApolloComposable.UseMutationReturn<DestroyPostMutation, DestroyPostMutationVariables>;
export const GetCompanyDocument = gql`
    query GetCompany($slug: String!, $first: Int = 10, $after: String = null) {
  company(slug: $slug) {
    slug
    name
    headquarters
    description
    users(first: $first, after: $after) {
      edges {
        node {
          slug
          nameWithCredentials
        }
        cursor
      }
      pageInfo {
        hasNextPage
        hasPreviousPage
        startCursor
        endCursor
      }
    }
  }
}
    `;

/**
 * __useGetCompanyQuery__
 *
 * To run a query within a Vue component, call `useGetCompanyQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCompanyQuery` returns an object from Apollo Client that contains result, loading and error properties
 * you can use to render your UI.
 *
 * @param variables that will be passed into the query
 * @param options that will be passed into the query, supported options are listed on: https://v4.apollo.vuejs.org/guide-composable/query.html#options;
 *
 * @example
 * const { result, loading, error } = useGetCompanyQuery({
 *   slug: // value for 'slug'
 *   first: // value for 'first'
 *   after: // value for 'after'
 * });
 */
export function useGetCompanyQuery(variables: GetCompanyQueryVariables | VueCompositionApi.Ref<GetCompanyQueryVariables> | ReactiveFunction<GetCompanyQueryVariables>, options: VueApolloComposable.UseQueryOptions<GetCompanyQuery, GetCompanyQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<GetCompanyQuery, GetCompanyQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<GetCompanyQuery, GetCompanyQueryVariables>> = {}) {
  return VueApolloComposable.useQuery<GetCompanyQuery, GetCompanyQueryVariables>(GetCompanyDocument, variables, options);
}
export function useGetCompanyLazyQuery(variables?: GetCompanyQueryVariables | VueCompositionApi.Ref<GetCompanyQueryVariables> | ReactiveFunction<GetCompanyQueryVariables>, options: VueApolloComposable.UseQueryOptions<GetCompanyQuery, GetCompanyQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<GetCompanyQuery, GetCompanyQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<GetCompanyQuery, GetCompanyQueryVariables>> = {}) {
  return VueApolloComposable.useLazyQuery<GetCompanyQuery, GetCompanyQueryVariables>(GetCompanyDocument, variables, options);
}
export type GetCompanyQueryCompositionFunctionResult = VueApolloComposable.UseQueryReturn<GetCompanyQuery, GetCompanyQueryVariables>;
export const GetPostDocument = gql`
    query GetPost($id: ID!, $first: Int = 10, $after: String = null) {
  post(id: $id) {
    body
    createdAt
    updatedAt
    user {
      slug
      nameWithCredentials
    }
    postComments(first: $first, after: $after) {
      edges {
        node {
          id
          body
          user {
            slug
            nameWithCredentials
          }
        }
        cursor
      }
      pageInfo {
        hasNextPage
        hasPreviousPage
        startCursor
        endCursor
      }
    }
  }
}
    `;

/**
 * __useGetPostQuery__
 *
 * To run a query within a Vue component, call `useGetPostQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPostQuery` returns an object from Apollo Client that contains result, loading and error properties
 * you can use to render your UI.
 *
 * @param variables that will be passed into the query
 * @param options that will be passed into the query, supported options are listed on: https://v4.apollo.vuejs.org/guide-composable/query.html#options;
 *
 * @example
 * const { result, loading, error } = useGetPostQuery({
 *   id: // value for 'id'
 *   first: // value for 'first'
 *   after: // value for 'after'
 * });
 */
export function useGetPostQuery(variables: GetPostQueryVariables | VueCompositionApi.Ref<GetPostQueryVariables> | ReactiveFunction<GetPostQueryVariables>, options: VueApolloComposable.UseQueryOptions<GetPostQuery, GetPostQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<GetPostQuery, GetPostQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<GetPostQuery, GetPostQueryVariables>> = {}) {
  return VueApolloComposable.useQuery<GetPostQuery, GetPostQueryVariables>(GetPostDocument, variables, options);
}
export function useGetPostLazyQuery(variables?: GetPostQueryVariables | VueCompositionApi.Ref<GetPostQueryVariables> | ReactiveFunction<GetPostQueryVariables>, options: VueApolloComposable.UseQueryOptions<GetPostQuery, GetPostQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<GetPostQuery, GetPostQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<GetPostQuery, GetPostQueryVariables>> = {}) {
  return VueApolloComposable.useLazyQuery<GetPostQuery, GetPostQueryVariables>(GetPostDocument, variables, options);
}
export type GetPostQueryCompositionFunctionResult = VueApolloComposable.UseQueryReturn<GetPostQuery, GetPostQueryVariables>;
export const GetPostsDocument = gql`
    query GetPosts($first: Int = 10, $after: String = null) {
  posts(first: $first, after: $after) {
    edges {
      node {
        id
        body
        createdAt
        updatedAt
        user {
          nameWithCredentials
          slug
        }
      }
      cursor
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
  }
}
    `;

/**
 * __useGetPostsQuery__
 *
 * To run a query within a Vue component, call `useGetPostsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPostsQuery` returns an object from Apollo Client that contains result, loading and error properties
 * you can use to render your UI.
 *
 * @param variables that will be passed into the query
 * @param options that will be passed into the query, supported options are listed on: https://v4.apollo.vuejs.org/guide-composable/query.html#options;
 *
 * @example
 * const { result, loading, error } = useGetPostsQuery({
 *   first: // value for 'first'
 *   after: // value for 'after'
 * });
 */
export function useGetPostsQuery(variables: GetPostsQueryVariables | VueCompositionApi.Ref<GetPostsQueryVariables> | ReactiveFunction<GetPostsQueryVariables> = {}, options: VueApolloComposable.UseQueryOptions<GetPostsQuery, GetPostsQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<GetPostsQuery, GetPostsQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<GetPostsQuery, GetPostsQueryVariables>> = {}) {
  return VueApolloComposable.useQuery<GetPostsQuery, GetPostsQueryVariables>(GetPostsDocument, variables, options);
}
export function useGetPostsLazyQuery(variables: GetPostsQueryVariables | VueCompositionApi.Ref<GetPostsQueryVariables> | ReactiveFunction<GetPostsQueryVariables> = {}, options: VueApolloComposable.UseQueryOptions<GetPostsQuery, GetPostsQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<GetPostsQuery, GetPostsQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<GetPostsQuery, GetPostsQueryVariables>> = {}) {
  return VueApolloComposable.useLazyQuery<GetPostsQuery, GetPostsQueryVariables>(GetPostsDocument, variables, options);
}
export type GetPostsQueryCompositionFunctionResult = VueApolloComposable.UseQueryReturn<GetPostsQuery, GetPostsQueryVariables>;
export const GetUserDocument = gql`
    query GetUser($slug: String!, $first: Int = 10, $after: String = null) {
  user(slug: $slug) {
    slug
    nameWithCredentials
    about
    company {
      slug
      name
    }
    connectionTotal
    posts(first: $first, after: $after) {
      edges {
        node {
          id
          body
        }
        cursor
      }
    }
  }
}
    `;

/**
 * __useGetUserQuery__
 *
 * To run a query within a Vue component, call `useGetUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserQuery` returns an object from Apollo Client that contains result, loading and error properties
 * you can use to render your UI.
 *
 * @param variables that will be passed into the query
 * @param options that will be passed into the query, supported options are listed on: https://v4.apollo.vuejs.org/guide-composable/query.html#options;
 *
 * @example
 * const { result, loading, error } = useGetUserQuery({
 *   slug: // value for 'slug'
 *   first: // value for 'first'
 *   after: // value for 'after'
 * });
 */
export function useGetUserQuery(variables: GetUserQueryVariables | VueCompositionApi.Ref<GetUserQueryVariables> | ReactiveFunction<GetUserQueryVariables>, options: VueApolloComposable.UseQueryOptions<GetUserQuery, GetUserQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<GetUserQuery, GetUserQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<GetUserQuery, GetUserQueryVariables>> = {}) {
  return VueApolloComposable.useQuery<GetUserQuery, GetUserQueryVariables>(GetUserDocument, variables, options);
}
export function useGetUserLazyQuery(variables?: GetUserQueryVariables | VueCompositionApi.Ref<GetUserQueryVariables> | ReactiveFunction<GetUserQueryVariables>, options: VueApolloComposable.UseQueryOptions<GetUserQuery, GetUserQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<GetUserQuery, GetUserQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<GetUserQuery, GetUserQueryVariables>> = {}) {
  return VueApolloComposable.useLazyQuery<GetUserQuery, GetUserQueryVariables>(GetUserDocument, variables, options);
}
export type GetUserQueryCompositionFunctionResult = VueApolloComposable.UseQueryReturn<GetUserQuery, GetUserQueryVariables>;
export const GetUserConnectionsDocument = gql`
    query GetUserConnections($slug: String!, $first: Int = 10, $after: String = null) {
  user(slug: $slug) {
    connectionTotal
    connections(first: $first, after: $after) {
      edges {
        cursor
        node {
          slug
          nameWithCredentials
        }
      }
      pageInfo {
        startCursor
        endCursor
        hasPreviousPage
        hasNextPage
      }
    }
  }
}
    `;

/**
 * __useGetUserConnectionsQuery__
 *
 * To run a query within a Vue component, call `useGetUserConnectionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserConnectionsQuery` returns an object from Apollo Client that contains result, loading and error properties
 * you can use to render your UI.
 *
 * @param variables that will be passed into the query
 * @param options that will be passed into the query, supported options are listed on: https://v4.apollo.vuejs.org/guide-composable/query.html#options;
 *
 * @example
 * const { result, loading, error } = useGetUserConnectionsQuery({
 *   slug: // value for 'slug'
 *   first: // value for 'first'
 *   after: // value for 'after'
 * });
 */
export function useGetUserConnectionsQuery(variables: GetUserConnectionsQueryVariables | VueCompositionApi.Ref<GetUserConnectionsQueryVariables> | ReactiveFunction<GetUserConnectionsQueryVariables>, options: VueApolloComposable.UseQueryOptions<GetUserConnectionsQuery, GetUserConnectionsQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<GetUserConnectionsQuery, GetUserConnectionsQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<GetUserConnectionsQuery, GetUserConnectionsQueryVariables>> = {}) {
  return VueApolloComposable.useQuery<GetUserConnectionsQuery, GetUserConnectionsQueryVariables>(GetUserConnectionsDocument, variables, options);
}
export function useGetUserConnectionsLazyQuery(variables?: GetUserConnectionsQueryVariables | VueCompositionApi.Ref<GetUserConnectionsQueryVariables> | ReactiveFunction<GetUserConnectionsQueryVariables>, options: VueApolloComposable.UseQueryOptions<GetUserConnectionsQuery, GetUserConnectionsQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<GetUserConnectionsQuery, GetUserConnectionsQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<GetUserConnectionsQuery, GetUserConnectionsQueryVariables>> = {}) {
  return VueApolloComposable.useLazyQuery<GetUserConnectionsQuery, GetUserConnectionsQueryVariables>(GetUserConnectionsDocument, variables, options);
}
export type GetUserConnectionsQueryCompositionFunctionResult = VueApolloComposable.UseQueryReturn<GetUserConnectionsQuery, GetUserConnectionsQueryVariables>;
export const GetUsersDocument = gql`
    query GetUsers($first: Int = 10, $after: String = null) {
  users(first: $first, after: $after) {
    edges {
      node {
        slug
        nameWithCredentials
      }
      cursor
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
  }
}
    `;

/**
 * __useGetUsersQuery__
 *
 * To run a query within a Vue component, call `useGetUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUsersQuery` returns an object from Apollo Client that contains result, loading and error properties
 * you can use to render your UI.
 *
 * @param variables that will be passed into the query
 * @param options that will be passed into the query, supported options are listed on: https://v4.apollo.vuejs.org/guide-composable/query.html#options;
 *
 * @example
 * const { result, loading, error } = useGetUsersQuery({
 *   first: // value for 'first'
 *   after: // value for 'after'
 * });
 */
export function useGetUsersQuery(variables: GetUsersQueryVariables | VueCompositionApi.Ref<GetUsersQueryVariables> | ReactiveFunction<GetUsersQueryVariables> = {}, options: VueApolloComposable.UseQueryOptions<GetUsersQuery, GetUsersQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<GetUsersQuery, GetUsersQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<GetUsersQuery, GetUsersQueryVariables>> = {}) {
  return VueApolloComposable.useQuery<GetUsersQuery, GetUsersQueryVariables>(GetUsersDocument, variables, options);
}
export function useGetUsersLazyQuery(variables: GetUsersQueryVariables | VueCompositionApi.Ref<GetUsersQueryVariables> | ReactiveFunction<GetUsersQueryVariables> = {}, options: VueApolloComposable.UseQueryOptions<GetUsersQuery, GetUsersQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<GetUsersQuery, GetUsersQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<GetUsersQuery, GetUsersQueryVariables>> = {}) {
  return VueApolloComposable.useLazyQuery<GetUsersQuery, GetUsersQueryVariables>(GetUsersDocument, variables, options);
}
export type GetUsersQueryCompositionFunctionResult = VueApolloComposable.UseQueryReturn<GetUsersQuery, GetUsersQueryVariables>;
export const UpdatePostDocument = gql`
    mutation UpdatePost($postId: ID!, $body: String!) {
  updatePost(input: {postId: $postId, body: $body}) {
    success
    errors
  }
}
    `;

/**
 * __useUpdatePostMutation__
 *
 * To run a mutation, you first call `useUpdatePostMutation` within a Vue component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePostMutation` returns an object that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - Several other properties: https://v4.apollo.vuejs.org/api/use-mutation.html#return
 *
 * @param options that will be passed into the mutation, supported options are listed on: https://v4.apollo.vuejs.org/guide-composable/mutation.html#options;
 *
 * @example
 * const { mutate, loading, error, onDone } = useUpdatePostMutation({
 *   variables: {
 *     postId: // value for 'postId'
 *     body: // value for 'body'
 *   },
 * });
 */
export function useUpdatePostMutation(options: VueApolloComposable.UseMutationOptions<UpdatePostMutation, UpdatePostMutationVariables> | ReactiveFunction<VueApolloComposable.UseMutationOptions<UpdatePostMutation, UpdatePostMutationVariables>> = {}) {
  return VueApolloComposable.useMutation<UpdatePostMutation, UpdatePostMutationVariables>(UpdatePostDocument, options);
}
export type UpdatePostMutationCompositionFunctionResult = VueApolloComposable.UseMutationReturn<UpdatePostMutation, UpdatePostMutationVariables>;