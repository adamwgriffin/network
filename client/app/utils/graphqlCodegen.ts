import gql from "graphql-tag";
import * as VueApolloComposable from "@vue/apollo-composable";
import * as VueCompositionApi from "@vue/composition-api";
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<
  T extends { [key: string]: unknown },
  K extends keyof T
> = { [_ in K]?: never };
export type Incremental<T> =
  | T
  | {
      [P in keyof T]?: P extends " $fragmentName" | "__typename" ? T[P] : never;
    };
export type ReactiveFunction<TParam> = () => TParam;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
  ISO8601DateTime: { input: any; output: any };
};

/** Autogenerated input type of AcceptConnectionRequest */
export type AcceptConnectionRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  connectionId: Scalars["ID"]["input"];
};

/** Autogenerated return type of AcceptConnectionRequest. */
export type AcceptConnectionRequestPayload = {
  __typename?: "AcceptConnectionRequestPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  errors: Array<Scalars["String"]["output"]>;
  success: Scalars["Boolean"]["output"];
};

export type Company = {
  __typename?: "Company";
  description?: Maybe<Scalars["String"]["output"]>;
  headquarters: Scalars["String"]["output"];
  id: Scalars["ID"]["output"];
  name: Scalars["String"]["output"];
  users?: Maybe<Array<User>>;
};

/** The connection type for Company. */
export type CompanyConnection = {
  __typename?: "CompanyConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CompanyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Company>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CompanyEdge = {
  __typename?: "CompanyEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Company>;
};

export type Connection = {
  __typename?: "Connection";
  createdAt: Scalars["ISO8601DateTime"]["output"];
  id: Scalars["ID"]["output"];
  /** The user who received the connection request */
  recipient: User;
  recipientId: Scalars["Int"]["output"];
  /** The user who sent the connection request */
  requester: User;
  requesterId: Scalars["Int"]["output"];
  status: Scalars["String"]["output"];
  updatedAt: Scalars["ISO8601DateTime"]["output"];
};

/** Autogenerated input type of DeclineConnectionRequest */
export type DeclineConnectionRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  connectionId: Scalars["ID"]["input"];
};

/** Autogenerated return type of DeclineConnectionRequest. */
export type DeclineConnectionRequestPayload = {
  __typename?: "DeclineConnectionRequestPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  errors: Array<Scalars["String"]["output"]>;
  success: Scalars["Boolean"]["output"];
};

export type Mutation = {
  __typename?: "Mutation";
  acceptConnectionRequest?: Maybe<AcceptConnectionRequestPayload>;
  declineConnectionRequest?: Maybe<DeclineConnectionRequestPayload>;
  removeConnection?: Maybe<RemoveConnectionPayload>;
  sendConnectionRequest?: Maybe<SendConnectionRequestPayload>;
};

export type MutationAcceptConnectionRequestArgs = {
  input: AcceptConnectionRequestInput;
};

export type MutationDeclineConnectionRequestArgs = {
  input: DeclineConnectionRequestInput;
};

export type MutationRemoveConnectionArgs = {
  input: RemoveConnectionInput;
};

export type MutationSendConnectionRequestArgs = {
  input: SendConnectionRequestInput;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: "PageInfo";
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars["String"]["output"]>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars["Boolean"]["output"];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars["Boolean"]["output"];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars["String"]["output"]>;
};

export type Query = {
  __typename?: "Query";
  /** Return a paginated list of companies */
  companies: CompanyConnection;
  /** Find a company by ID */
  company?: Maybe<Company>;
  /** Find a user by ID */
  user?: Maybe<User>;
  /** Return a paginated list of users */
  users: UserConnection;
};

export type QueryCompaniesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

export type QueryCompanyArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryUserArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryUsersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Autogenerated input type of RemoveConnection */
export type RemoveConnectionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  connectionId: Scalars["ID"]["input"];
};

/** Autogenerated return type of RemoveConnection. */
export type RemoveConnectionPayload = {
  __typename?: "RemoveConnectionPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  errors: Array<Scalars["String"]["output"]>;
  success: Scalars["Boolean"]["output"];
};

/** Autogenerated input type of SendConnectionRequest */
export type SendConnectionRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  recipientId: Scalars["ID"]["input"];
  requesterId: Scalars["ID"]["input"];
};

/** Autogenerated return type of SendConnectionRequest. */
export type SendConnectionRequestPayload = {
  __typename?: "SendConnectionRequestPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  errors: Array<Scalars["String"]["output"]>;
  success: Scalars["Boolean"]["output"];
};

export type User = {
  __typename?: "User";
  company: Company;
  companyId: Scalars["Int"]["output"];
  /** All accepted connections for this user */
  connections?: Maybe<Array<User>>;
  /** The post-nominal letters (e.g., M.D.) for the user */
  credentials?: Maybe<Scalars["String"]["output"]>;
  firstName: Scalars["String"]["output"];
  id: Scalars["ID"]["output"];
  lastName: Scalars["String"]["output"];
  middleName?: Maybe<Scalars["String"]["output"]>;
  nickname?: Maybe<Scalars["String"]["output"]>;
  /** Pending connection requests received by this user */
  pendingReceivedRequests?: Maybe<Array<Connection>>;
  /** Pending connection requests sent by this user */
  pendingSentRequests?: Maybe<Array<Connection>>;
};

/** The connection type for User. */
export type UserConnection = {
  __typename?: "UserConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: "UserEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

export type GetUserQueryVariables = Exact<{
  id: Scalars["ID"]["input"];
}>;

export type GetUserQuery = {
  __typename?: "Query";
  user?: {
    __typename?: "User";
    id: string;
    firstName: string;
    lastName: string;
    credentials?: string | null;
    company: { __typename?: "Company"; id: string; name: string };
  } | null;
};

export const GetUserDocument = gql`
  query GetUser($id: ID!) {
    user(id: $id) {
      id
      firstName
      lastName
      credentials
      company {
        id
        name
      }
    }
  }
`;

/**
 * __useGetUserQuery__
 *
 * To run a query within a Vue component, call `useGetUserQuery` and pass it any
 * options that fit your needs. When your component renders, `useGetUserQuery`
 * returns an object from Apollo Client that contains result, loading and error
 * properties you can use to render your UI.
 *
 * @param variables that will be passed into the query
 * @param options that will be passed into the query, supported options are
 * listed on: https://v4.apollo.vuejs.org/guide-composable/query.html#options;
 *
 * @example
 * const { result, loading, error } = useGetUserQuery({
 *   id: // value for 'id'
 * });
 */
export function useGetUserQuery(
  variables:
    | GetUserQueryVariables
    | VueCompositionApi.Ref<GetUserQueryVariables>
    | ReactiveFunction<GetUserQueryVariables>,
  options:
    | VueApolloComposable.UseQueryOptions<GetUserQuery, GetUserQueryVariables>
    | VueCompositionApi.Ref<
        VueApolloComposable.UseQueryOptions<GetUserQuery, GetUserQueryVariables>
      >
    | ReactiveFunction<
        VueApolloComposable.UseQueryOptions<GetUserQuery, GetUserQueryVariables>
      > = {}
) {
  return VueApolloComposable.useQuery<GetUserQuery, GetUserQueryVariables>(
    GetUserDocument,
    variables,
    options
  );
}
export function useGetUserLazyQuery(
  variables?:
    | GetUserQueryVariables
    | VueCompositionApi.Ref<GetUserQueryVariables>
    | ReactiveFunction<GetUserQueryVariables>,
  options:
    | VueApolloComposable.UseQueryOptions<GetUserQuery, GetUserQueryVariables>
    | VueCompositionApi.Ref<
        VueApolloComposable.UseQueryOptions<GetUserQuery, GetUserQueryVariables>
      >
    | ReactiveFunction<
        VueApolloComposable.UseQueryOptions<GetUserQuery, GetUserQueryVariables>
      > = {}
) {
  return VueApolloComposable.useLazyQuery<GetUserQuery, GetUserQueryVariables>(
    GetUserDocument,
    variables,
    options
  );
}
export type GetUserQueryCompositionFunctionResult =
  VueApolloComposable.UseQueryReturn<GetUserQuery, GetUserQueryVariables>;
